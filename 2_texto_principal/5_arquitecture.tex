% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% State of the art
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\fancychapter{Arquitectura do Sistema}
\label{chap:5}

\section{Sistema de Monitorização EMoS}
\label{chap:5:sec:1}
Propõe-se nesta tese o \acf{EMoS}, uma solução simulada para o problema da monitorização de pessoas em ambiente doméstico. O \acs{EMoS} é uma rede \acs{WSN} constituída por diversos nós com comunicação wireless colocados de forma homogénea numa casa. Embora o sistema possa efectuar a monitorização de todo o tipo de pessoas, neste trabalho é focada a monitorização de idosos ou pessoas com necessidades especiais. 

São sugeridas opções de hardware comercialmente disponíveis para cada componente do sistema, pretendendo-se desta forma ir para além da simples simulação e obter parâmetros reais para a configuração da mesma. Alguns aspectos de hardware mencionados não serão simulados por limitação de tempo na execução deste trabalho e também por não corresponderem ao âmbito estabelecido no Capítulo \ref{chap:1:sec:2}.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=1\textwidth]{img/05_emos_overview.png}
  \caption{Esquema modular do \textit{Elder Monitorization System} (EMoS).}
  \label{fig:1:emosOverview}
\end{figure}

O sistema \acs{EMoS} (Figura \ref{fig:1:emosOverview}) é caracterizado pelos seguintes tipos de dispositivos:

\begin{itemize}
\item Nó Móvel (\acf{MN}): Monitorização de pessoas e calibração do sistema;
\item Nó Fixo (\acf{SN}): Envio de \textit{beacons} para localização, comunicação e monitorização doméstica;
\item Nó Base (\acf{BN}): Gestão central do sistema recebendo os dados de monitorização ou pedidos do utilizador e enviando mensagens para a rede \acs{WSN} ou para o exterior através de uma \acs{LAN}.
\end{itemize}

Os nós fixos estão ligados à rede eléctrica e enviam periodicamente  mensagens de assinatura em modo \textit{broadcast}. No caso dos nós \textit{SN8}, \textit{SN9}, \textit{SN12} e \textit{SN13}, pode existir também envio de mensagens para outros nós fixos ou para o nó base. Isto pode acontecer quando por exemplo, é detectado gás no caso do \textit{SN12}, quando é ligado/desligado o fogão no caso do \textit{SN13} ou quando alguém se deita/levanta numa das camas onde estão os sensores \textit{SN8} e \textit{SN9}.

O nó base recebe informação dos nós fixos ou do exterior através da \acs{LAN} e toma decisões com base nessa informação. Pode, por exemplo, avisar num monitor que existe alguma anomalia na casa, enviar uma mensagem para o nó móvel ou para um nó fixo, ou comunicar com o exterior caso seja necessário. 

O nó móvel pode funcionar em dois modos: calibração e normal. No modo de calibração limita-se a receber assinaturas dos nós fixos e a registar essa informação, gerando um ficheiro XML com o mapa rádio do casa. No modo normal recebe de igual forma as assinaturas, mas periodicamente envia de volta para o nó fixo mais próximo, um conjunto de médias das potências recebidas. O nó fixo por sua vez envia esta informação para o nó base que irá calcular a localização do nó móvel.

Todos os nós formam uma estrutura em \textit{flat-routing} usando o \acs{AODV} para comunicar e apresentam uma estrutura interna idêntica (Figura \ref{fig:2:emonsNodeInternal}). O sistema é perfeitamente escalável, sendo possível adicionar-se vários outros nós móveis. No caso de existir um número muito elevado de nós móveis, é possível criar novos nós base associados a \textit{clusters} de nós fixos, que comuniquem através da LAN para eliminar sobreposições.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.78\textwidth]{img/05_emos_node_internal.png}
  \caption{Estrutura interna de um nó no sistema EMoS.}
  \label{fig:2:emonsNodeInternal}
\end{figure}

\clearpage

Neste trabalho foi criada uma camada \textit{Network} comum para todos os nós e uma camada \textit{Application} por cada tipo de nó que implementa cada u dos tipos descritos. Nas próximas secções é feita uma exposição detalhada de todo o sistema.

\subsection{Nó Móvel (MN)}
\label{chap:5:sec:1.1}

O nó móvel é um sensor equipado com rádios \acs{IEEE} 802.15.4 e Bluetooth, um acelerómetro, um botão de pânico e capacidade de armazenamento em cartão \acs{SD}. O facto de ter dois tipos de rádio permite-lhe comunicar com ambas as redes \acs{BSN} para monitorização local biomédica e \acs{WSN}. Está instalado num objecto de uso diário, como uma bengala, um andarilho ou uma cadeira de rodas e possui baterias recarregáveis. O carregamento é feito no sítio habitual de apoio da bengala ou então por ligação com as baterias de uma cadeira de rodas eléctrica.

A rede \acs{BSN} é composta por um electrocardiógrafo e um medidor de pressão arterial ambos equipados com Bluetooth, que efectuam monitorização contínua. Quando detectam uma situação anómala comunicam a mesma ao nó móvel. Na simulação este comportamento é recreado com um temporizador aleatório no nó móvel que simula a comunicação vinda da \acs{BSN} ao nível da aplicação.

Como solução de hardware sugere-se a utilização do módulo \textit{Waspmote} (Figura \ref{fig:3:waspMote}, com rádio \textit{XBee-802.15.4} (Figura \ref{fig:4:waspXBee}), da \textit{Libelium}\footnote{http://www.libelium.com/products/waspmote} que permite a utilização de dois tipos de rádio, tem acelerómetro integrado, micro\acs{SD} e pins para obtenção do \acs{RSSI}. 

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.57\textwidth]{img/05_wasp_mote.png}
  \caption{Módulo \textit{Waspmote} da \textit{Libelium}.}
  \label{fig:3:waspMote}
\end{figure}

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.40\textwidth]{img/05_wasp_xbee.png}
  \caption{Rádio \textit{XBee} IEEE 802.15.4 usado no módulo \textit{Waspmote}.}
  \label{fig:4:waspXBee}
\end{figure}

O rádio \textit{XBee} simulado terá os seguintes parâmetros obtidos do  manual  \footnote{http://ftp1.digi.com/support/documentation/90000982\_H.pdf}): 

\begin{table}[!htb]
	\centering
\begin{tabular}{ |l|r|}
	\hline
  	Parâmetro & Valor \\
  	\hline
  	Modulation & O-QPSK \\
  	Receiver Sensitivity & -92 dbM  \\
  	Transmit Power	& 1mW \\
  	Sleep Current & <10 uA \\
  	Current Consumption RX & 50 mA \\
  	Current Consumption TX (P=0dBm) & 45 mA \\
  	\hline
\end{tabular}
	\caption{Parâmetros do rádio \textit{XBee} da \textit{Digi}.}
	\label{tab:1:xbeeNICParameters}
\end{table}

\subsection{Nó Fixo (SN)}
\label{chap:5:sec:1.2}

O nó fixo está equipado com rádio \acs{IEEE} 802.15.4. Ficará ligado à rede eléctrica dada a necessidade de estar periodicamente a enviar assinaturas em \textit{broadcast}. O hardware escolhido para a implementação deste nó será o \textit{MicaZ} com rádio \textit{Texas Instruments CC2420} da \textit{Crossbow}\footnote{http://www.xbow.com/} (Figura \ref{fig:5:micaz}).

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.35\textwidth]{img/05_micaz.png}
  \caption{Módulo \textit{Micaz} da \textit{Crossbow}.}
  \label{fig:5:micaz}
\end{figure}

A escolha deste nó é motivada pelo baixo custo do mesmo e o facto de ser o nó que estará presente em maior número na rede.

O rádio \textit{Texas Instruments CC2420} tem os seguintes parâmetros obtidos do manual\footnote{http://www.ti.com/lit/gpn/cc2420};
\begin{table}[!htb]
	\centering
\begin{tabular}{ |l|r|}
	\hline
  	Parâmetro & Valor \\
  	\hline
  	Modulation & O-QPSK \\
  	Receiver Sensitivity & -95 dBm  \\
  	Transmit Power & 1.1mW \\
  	Sleep Current & 0.02 uA \\
  	Current Consumption RX & 18.8 mA \\
  	Current Consumption TX (P=0dBm) & 17.4 mA \\
  	\hline
\end{tabular}
	\caption{Parâmetros do rádio \textit{Texas Instruments CC2420}.}
	\label{tab:2:CC2420NICParameters}
\end{table}

\subsection{Nó Base (BN)}
\label{chap:5:sec:1.3}

O nó base tem como função efectuar toda a gestão centralizada da informação gerada por cada um dos sensores. Dada a grande necessidade de rapidez de processamento, espaço de armazenamento e comunicação com o exterior, optou-se por usar um \acs{PC} ligado a uma \acs{LAN} que está por sua vez ligada à Internet. Assim o hardware para a implementação física deste nó e que fará a ponte entre o \acs{PC} e a rede \acs{WSN}, será o \textit{Waspmote Gateway}, com rádio \textit{XBee-802.15.4} (Figura \ref{fig:4:waspXBee}), da \textit{Libelium}. 

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.40\textwidth]{img/05_waspmote_gateway.png}
  \caption{Módulo \textit{Waspmote Gateway} da \textit{Libelium}.}
  \label{fig:6:waspmoteGateway}
\end{figure}

Este nó usa o mesmo rádio que o \textit{Waspmote}, com parâmetros para simulação já registados na Tabela \ref{tab:1:xbeeNICParameters}.

\clearpage

\section{Camada \textit{Network} : \textit{AODVRoute}}
\label{chap:5:sec:3}

A tecnologia ZigBee é hoje bastante usada nas redes \acs{WSN} com vários produtos para as mais diversas áreas. O ZigBee usa como primeiro protocolo na camada \textit{Network} o \acf{AODV} e seguidamente quando este falha um protocolo hierárquico. Assim por forma a garantir uma compatibilidade do sistema desenvolvido com o ZigBee optou-se por implementar este protocolo no \acs{MiXiM}. 

O \acs{AODV} é um protocolo \textit{on-demand} que permite descobrir um caminho apenas quando este é necessário, recuperar caminhos perdidos e reutilizar caminhos já encontrados. Achou-se por isso conveniente implementá-lo no \acs{MiXiM} para ser usado no \acs{EMoS}. Este usa caminhos bidireccionais, o que significa que quando é feita a descoberta de um novo caminho são sempre gerados dois, acelerando o processo de procura de novos caminhos. A utilização de contadores sequenciais impede e formação de loops em todo o processo e é feita manutenção sobre os caminhos para eliminar os que deixaram de ser usados durante um determinado espaço de tempo.

Neste trabalho foi implementada uma versão do \acs{AODV} que apenas contém as funcionalidades necessárias para descoberta de um novo caminho ou para a recuperação de um caminho perdido. O \textit{multicast} bem como a reparação local de caminhos perdidos (\textit{local-repair}\footnote{reparação que ocorre localmente quando um nó intermédio falha no encaminhamento da mensagem.}) não foram implementadas. Ao módulo implementado foi dado o nome de \textit{AODVRoute}.

\subsection{Tipos de Mensagens}
\label{chap:5:sec:3.1}
O \acs{AODV} funciona utilizando pelo menos três tipos de mensagens para descobrir o caminho de um nó A para um nó B.

\begin{itemize}
\item \acf{RREQ};
\item \acf{RREP};
\item \acf{RERR}.
\end{itemize}

Pode ainda existir um quarto tipo de mensagem, opcional, o \acf{RREP-ACK}, utilizado quando existe o perigo de existirem ligações unidireccionais que impeçam a chegada de um \acs{RREP}, mas que não será referido neste trabalho.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=1\textwidth]{img/05_aodv_msg_types.png}
  \caption{Tipos de mensagens do AODVRoute.}
  \label{fig:11:aodvMsgTypes}
\end{figure}

Na Figura \ref{fig:11:aodvMsgTypes} estão as mensagens criadas no \acs{MiXiM}. A criação de mensagens no \acs{OMNeT++} é relativamente simples uma vez que todo o \textit{boilerplate code} é gerado automaticamente. Assim é necessário apenas definir ficheiros do tipo \textit{msg} com os parâmetros necessários. Cada uma das mensagens definidas para este módulo estende a mensagem \textit{NetwPkt}, uma mensagem genérica para a camada \textit{Netw} com endereços de emissor e receptor e \acf{TTL}. Para além dos campos herdados existem também os seguintes campos para cada tipo de mensagem:

\begin{itemize}
\item \textit{AODVRouteRequest} : endereços e números de sequência para o nós emissor e receptor, o \textit{RREQ\_ID} que é obtido de um contador existente para o efeito no nó emissor e o contador de saltos que permite perceber em que ponto do caminho está o \acs{RREQ};
\item \textit{AODVRouteResponse} : endereços de emissor e receptor, número de sequência do nó de receptor e número de saltos até ao receptor;
\item \textit{AODVRouteError} : endereço do nó de destino que não foi encontrado. 
\end{itemize}

\subsection{Estruturas de Dados}
\label{chap:5:sec:3.2}

Foram criadas três estruturas de dados neste novo módulo:

\begin{itemize}
\item \textit{pktMap} : utilizada para guardar os pacotes que vieram da camada \acs{APP} por nó de destino, num \acs{FIFO} quando para estes ainda não existe um caminho encontrado;
\item \textit{RREQVector} : utilizada para guardar os pacotes \acs{RREQ} recebidos;
\item \textit{routeMap} :utilizada para guardar as rotas em cada nó e a lista de precursores\footnote{Precursor de um caminho, é um nó que antecede o nó actual no caminho e só existe depois de ter enviado pelo menos uma mensagem pelo nó actual.} dessa rota.
\end{itemize}

\begin{figure}[!htb]
  \centering
  \includegraphics[width=1\textwidth]{img/05_aodv_pkt_map.png}
  \caption{PktMap - estrutura para a gestão dos pacotes de aplicação em espera.}
  \label{fig:8:aodvPktMap}
\end{figure}

Na Figura \ref{fig:8:aodvPktMap} observamos a estrutura PktMap. Este mapa de pares do tipo de endereços e filas de pacotes, guarda para cada nó de destino os pacotes em espera de um caminho para o seu destino final. Cada elemento da fila tem como parâmetros o endereço do nó de destino, o tempo de vida do elemento (\begin{math}t_0+t\end{math}) e o pacote que foi enviado da camada \acs{APP}. Esta estrutura é sujeita a uma manutenção periódica que elimina os todos os elementos para os quais \begin{math}t_{sim}>lifetime\end{math}. O tempo de vida é suficientemente curto para que não exista uma disparidade grande entre o momento que foi encontrado um caminho e a nova posição do nó móvel.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=1\textwidth]{img/05_aodv_rreq_vector.png}
  \caption{RREQVector - estrutura que guarda os RREQs recebidos num nó.}
  \label{fig:9:aodvRREQVec}
\end{figure}

Na Figura \ref{fig:9:aodvRREQVec} observamos a \textit{RREQVec}, estrutura que guarda a chave pares \textit{RREQ\_ID} e \textit{srcAddr}, por forma a distinguir univocamente todos os \acp{RREQ} recebidos de um determinado nó evitando assim o envio de um \acs{RREQ} que já foi anteriormente enviado.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=1\textwidth]{img/05_aodv_route_map.png}
  \caption{RouteMap - estrutura que guarda os caminhos encontrados para nós destino.}
  \label{fig:10:aodvPktMap}
\end{figure}

Finalmente na Figura \ref{fig:10:aodvPktMap} temos a estrutura \textit{RouteMap} que guarda a informação dos caminhos encontrados em cada nó. Estão presentes em cada \textit{routeMapElement}, o nó final de destino do caminho, o número de sequência conhecido do destino, o próximo nó do caminho, o número de nós entre o nó actual e o nó de destino, o tempo de vida do caminho usado para garantir que os caminhos que deixaram de ser usados não ficam a ocupar espaço no limitado armazenamento disponível e uma lista de nós precursores que servirá para para enviar um \acs{RERR} de volta para todos os nós que anteriormente usaram o caminho que deixou de existir.

\subsection{Modo de Funcionamento}
\label{chap:5:sec:3.3}

Neste trabalho a camada de aplicação poderá gerar vários tipos de mensagens. Essas mensagens poderão ser em \textit{broadcast} no caso das mensagens de assinatura enviadas pelos nós fixos ou \textit{unicast} quando existe um nó que pretende comunicar com outro. Todos os nós do sistema \acs{EMoS} podem comunicar uns com os outros, no entanto, nem sempre de forma directa. Sendo a camada \textit{Network} comum a todos os nós o comportamento é idêntico para todos. 

Suponhamos que a camada de aplicação de um nó fixo pretende enviar uma mensagem para o nó base, informando que o existe uma fuga de gás. A partir desse momento à mensagem de aplicação é anexada informação de controlo (\textit{NetwControlInfo}), contendo o endereço \textit{Network} do nó de destino, sendo enviada para a camada abaixo. A mensagem segue então o fluxograma da Figura \ref{fig:12:aodvFlux1}. De notar que o caso em que o endereço de destino é igual ao do próprio nó, decorre de um erro de atribuição do endereço final na camada de aplicação. A incrementação da sequência do nó é feita para o caso de ainda existir \acp{RREQ} perdidos no ambiente.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.9\textwidth]{img/05_aodv_flow_01.png}
  \caption{Fluxograma de chegada da mensagem de aplicação à camada \textit{Network}.}
  \label{fig:12:aodvFlux1}
\end{figure}

Cada nó guarda também um registo, para cada nó com o qual já tenha comunicado um registo do número de sequência desse nó. Este valor é colocado no \acs{RREQ} para que, caso seja encontrado um caminho mais recente, este pedido seja ignorado.

Portanto quando não existe caminho para o nó pretendido de destino, o nó de origem gera o \acs{RREQ} que é enviado em modo \textit{broadcast} para o resto da rede. Na Figura \ref{fig:13:aodvFlux2} está a recepção de outro nó do pacote enviado pelo nó de origem. 

\begin{figure}[!htb]
  \centering
  \includegraphics[width=1\textwidth]{img/05_aodv_flow_02.png}
  \caption{Fluxograma de chegada de um \textit{RREQ} vindo da camada \textit{MAC}.}
  \label{fig:13:aodvFlux2}
\end{figure}


Dado que o nó guarda todos os \acs{RREQ} que recebe no \textit{RouteVector}, este consegue verificar se já recebeu aquele mesmo pacote ou não. No caso de não ter recebido é incrementado o contador de saltos para que a distância até á origem seja actualizada. A informação do nó de origem, o número de saltos até ao mesmo são usados para criar um caminho inverso para o nó de origem. Enquanto este não for o nó de origem a mensagem vai sendo enviada de nó para nó até chegar ao destino. Pode ainda se dar o caso do nó não ser o nó de destino mas já existir um caminho no \textit{RouteMap}, o que permite ao nó intermédio devolver logo um \acs{RREP}. Quando se trata do nó de destino, é incrementado o contador do nó para garantir que não haverá mais nenhum caminho que se sobreponha.  

Então, assim que o caminho é encontrado, existe um \acs{RREP} que volta pelo caminho inverso em \textit{unicast} construindo o caminho do nó de origem para o nó de destino iniciais. 

\clearpage

Na Figura \ref{fig:14:aodvFlux3} podemos observar o que acontece a essa mensagem à medida que vai passando pelos nós intermédios até chegar ao nó de origem original. Quando é alcançada a origem, o nó pode então ir buscar ao pktMap, a próxima mensagem e enviá-la para aquele endereço de destino.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.7\textwidth]{img/05_aodv_flow_03.png}
  \caption{Fluxograma de chegada de um \textit{RREP} vindo da camada \textit{MAC}.}
  \label{fig:14:aodvFlux3}
\end{figure}

Quando ocorre um erro, ou seja, existe uma mensagem que é entregue mas o \acs{MAC} não recebe uma resposta de confirmação \acs{ACK}, é necessário tomar medidas para que a origem seja informada que aquele caminho já não é válido. Assim são criados \acs{RERR} que viajam pelos precursores até atingir nó de origem. Na Figura \ref{fig:15:aodvFlux4} podemos ver a primeira fase quando a falha na entrega da mensagem ocorre. Nesse momento o nó procura todos os caminhos que estejam no \textit{RouteMap} e elimina-os, enviando depois um \acs{RERR} para cada um dos precursores.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.33\textwidth]{img/05_aodv_flow_04.png}
  \caption{Fluxograma de chegada de uma mensagem de controlo com o pacote cuja entrega falhou no \textit·{MAC}.}
  \label{fig:15:aodvFlux4}
\end{figure}

Na Figura \ref{fig:16:aodvFlux5}  temos o comportamento dos nós intermédios e destino (origem do caminho eliminado). De notar que a mensagem vai sendo apagada, nó a nó, quando para cada percurso na árvore já não existem mais percursores.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.70\textwidth]{img/05_aodv_flow_05.png}
  \caption{Fluxograma da chegada de um \textit{RERR} vindo da camada \textit{MAC}.}
  \label{fig:16:aodvFlux5}
\end{figure}

\clearpage

\section{Camada \textit{Application} : Localização}
\label{chap:5:sec:4}

O sistema \acs{EMoS} usa para a localização o método \textit{HORUS} \cite{31} com algumas modificações que serão descritas na Secção \ref{chap:5:sec:4.1}. É um processo probabilístico com precisão elevada, razão pela qual foi escolhido para este trabalho. O processo  foi implementando completamente ao nível da camada de aplicação e é constituído por duas fases distintas:

\begin{itemize}
\item Fase \textit{Offline} : fase onde é obtido o mapa rádio e criados os \textit{clusters}. O nó móvel (\acs{MN}) é configurado em modo de calibração e guarda numa estrutura de dados, as assinaturas recebidas vindas dos diversos nós fixos que estão à distância de recepção. No fim da simulação são criados dois ficheiros \textit{XML} que guardam posições ou \textit{clusters}. Esses ficheiros serão posteriormente interpretados pelo nó base.
\item Fase \textit{Online} : fase em que os nó móveis enviam periodicamente mensagens com um conjunto de médias das potências recebidas dos vários nós fixos para o nó base. Utilizando o mapa rádio entretanto criado o nó base efectua o cálculo da posição seleccionando primeiramente um \textit{cluster} de posições e depois calculando a probabilidade de cada posição.
\end{itemize}

\subsection{HORUS Modificado}
\label{chap:5:sec:4.1}

O sistema \textit{HORUS} usado no \acs{EMoS} difere do apresentado pelo seu autor em \cite{31}, na medida em que o cálculo da posição não é feito no nó móvel mas sim no nó base, sendo a correlação entre amostras a única operação que permanece no dispositivo móvel. Esta opção de arquitectura deveu-se às seguintes razões:

\begin{itemize}
\item Poupança de bateria no nó móvel;
\item Fraca capacidade de processamento do nó móvel;
\item Necessidade de centralização das posições de vários nós móveis num único sítio podendo assim ser feita a correlação de resultados vindos de todos os nós;
\item Complexidade do sistema de localização.
\end{itemize}

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.85\textwidth]{img/05_horus_mod.png}
  \caption{Componentes do sistema HORUS modificado e fluxo de informação.}
  \label{fig:17:horusMod}
\end{figure}

\title{\textbf{\textit{Fase Offline}}}

Na Figura \ref{fig:17:horusMod} é descrito de forma global e modular todo o sistema de localização implementado. Na fase \textit{offline} o nó móvel recolhe para cada posição da casa uma séries de amostras (\textit{Raw Data}),pares (nodeAddress,RSSI) obtidos a partir da informação de controlo enviada pela camada \textit{Network}. Esta informação vai sendo guardada, sem qualquer tratamento, para todas as posições registadas. 

Depois de concluída a amostragem de todo o espaço a informação é agrupada por posição no \textit{Radio Map Builder} e correlacionada efectuando para cada posição e para cada nó, o cálculo da média e do desvio padrão, das potências recebidas no \textit{Correlation Modeler}. Em cada posição é mantido um número máximo configurável de nós registados, sendo todos os outros removidos, pretendendo-se com isto garantir que na fase \textit{Online} as amostras recebidas são cruzadas com amostras do mesmo tamanho para cada posição.

Por fim é feita a criação de \textit{clusters} no módulo \textit{Clustering}. O processo decorre ordenando por potência recebida as amostras para cada posição e depois escolhendo as \begin{math}n\end{math} primeiras como chave da posição. Para cada chave diferente é criado um novo \textit{cluster}. De notar que a chave (1000,1001) é igual à chave (1001,1000) não havendo o conceito de ordenação na chave. Neste trabalho considerou-se \begin{math}n=2\end{math} por ser um valor apontado no trabalho \cite{31} como tendo bons resultados num sistema real.

Para efeitos de simulação este comportamento foi emulado usando o módulo de mobilidade \textit{TractorMobility} disponibilizado pelo \acs{MiXiM} e descrito na Secção \ref{chap:5:sec:5}.Foram registadas posições separadas na horizontal por 1 metro e na vertical por 2 metros para toda a área de trabalho, em períodos de 40 segundos. Após cada mudança de posição, o nó móvel simulado calcula a média e o desvio padrão dos valores de \acs{RSSI} recebidos e guarda numa estrutura de dados de posições  \textit{radioMap} (ver Secção \ref{chap:5:sec:4.2}). Quando a simulação termina o \textit{radioMap} é transformado num ficheiro XML e são criados os \textit{clusters} da forma descrita no parágrafo anterior, que também são transformados num ficheiro XML.

\title{\textbf{\textit{Fase Online}}}

Nesta fase o nó móvel recolhe e guarda assinaturas dos nós fixos durante um determinado tempo. Após esse momento usa o \textit{Correlation Handler} para efectuar uma média por nó fixo, das diversas potências recebidas. Esse resultado é enviado para o nó com o o maior valor de \acs{RSSI} detectado até esse momento. O nó fixo reconhece o tipo de mensagem e envia directamente ou através de outros nós fixos, a mensagem para o nó base.  

O nó base contém os ficheiros XML gerados na fase \textit{offline} e como tal possui toda a informação necessária para determinar a probabilidade do nó estar numa determinada posição. Inicialmente a estimativa é discreta (\textit{Discrete-Space Estimator}) e apenas são determinadas posições para o nó móvel que constam no mapa rádio. 

Nesse momento o nó fixo analisa o sinal recebido, verifica se estão presentes um número mínimo de nós fixos e determina a chave da amostra (neste caso os dois nós com maior \acs{RSSI}). Com essa chave obtém o \textit{cluster} correspondente e as posições associadas. Para cada posição é calculada a densidade de probabilidade da distribuição normal (Ver Secção \ref{chap:5:sec:4.2}). A posição com maior valor é a posição obtida à saída do \textit{Discrete-Space Estimator}.

Uma vez que existem diversas posições onde o nó móvel poderá estar, que não estão registadas no mapa rádio é necessária uma estimação no espaço contínua. É essa precisamente a função do \textit{Continuous-Space Estimator} que irá através de duas técnicas: centro de massa das posições e média temporal do espaço físico, determinar uma posição estimada da posição real do nó.

\subsection{Modelo Matemático}
\label{chap:5:sec:4.2}

O sistema \textit{HORUS} é um método probabilístico.Neste trabalho optou-se pela parametrização do sinal recebido, que permite obter uma distribuição normal que se ajusta ao histograma das potências recebidas tal como podemos ver na Figura \ref{fig:23:horusNormal}.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.8\textwidth]{img/05_horus_normal.png}
  \caption{Exemplo de parametrização da distribuição de potência do sinal recebido \cite{31}.}
  \label{fig:23:horusNormal}
\end{figure}

A função densidade de probabilidade da distribuição normal é dada por:

\begin{equation}
fdp(q) = \frac{1}{\sigma{}\sqrt{2\pi{}}}e^\frac{-(q-\mu)^2}{2\sigma{}^2}
\label{eq1}
\end{equation}

Para \begin{math}n\end{math} amostras recebidas por um nó fixo \begin{math}i\end{math} os parâmetros de  \eqref{eq1} são obtidos, calculando a média e o desvio padrão das amostras obtidas, usando as equações \ref{eq2} e \ref{eq3}.

\begin{equation}
\mu{} = \frac{1}{n}\sum_{j=1}^{n} s_i(j)\
\label{eq2}\
\end{equation}

\begin{equation}
\sigma{} = \sqrt{\frac{1}{n}\sum_{j=1}^{n}(s_i(j)-\mu{})^2}
\label{eq3}
\end{equation}

onde \begin{math}s_i(j)\end{math} é a amostra \begin{math}j\end{math} proveniente do nó fixo \begin{math}i\end{math}.

O facto de se aproximar as amostras a uma função densidade de probabilidade permite uma poupança significativa de espaço de armazenamento, uma vez que deixa de ser necessário guardar os valores das potências recebidas. Para cada par (nó,posição) passa por isso a ser necessário guardar apenas a média e desvio padrão da função. Esta abordagem permite também obter valores de probabilidade para potências de sinal que não tenham sido medidas e filtrar possíveis anomalias registadas durante a fase \textit{offline}. 

Na fase \textit{online} é necessário calcular a probabilidade de um nó estar numa determinada posição. Assim é necessário para um vector \begin{math}s=(s_1,...,s_k)\end{math} encontrar a posição \begin{math}x\end{math} que maximiza a probabilidade \begin{math}P(x/s)\end{math}. Para obter esta probabilidade usando a função densidade de probabilidade entretanto guardada recorremos à equação:

\begin{equation}
P(s_i/x) =  P(s_i<=0.5) = \int_{s_i-0.5}^{s_i+0.5} fdp(q) dq
\label{eq4}
\end{equation}

Dado que queremos evitar a utilização de algoritmos numéricos, computacionalmente pesados, para a resolução do integral, transformou-se a função densidade de probabilidade encontrada para cada nó estático, numa função de distribuição normal standard, cujos valores podem ser tabelados. Para efeitos de simulação criou-se por isso, um ficheiro XML que contém os valores necessários.

Assim sabendo que:

\begin{equation}
P(X<=x) = P(\frac{X-\mu{}}{\sigma{}} <= \frac{x-\mu{}}{\sigma{}}) = P(Z<=z)
\end{equation}

onde \begin{math}Z\end{math} é uma variável normal aleatória standard, podemos calcular a probabilidade da \eqref{eq4} como:

\begin{equation}
P(s_i<=0.5) = P(Z<=\frac{s_i+0.5-\mu{}}{\sigma{}_i})
\end{equation}

onde com os valores tabelados rapidamente chegamos a um resultado.

Para um amostra que contenha vários nós estáticos, a probabilidade conjunta é dada pela multiplicação das probabilidades individuais calculadas para cada nó:

\begin{equation}
P = \prod_{j=1}^{n} P_i
\end{equation}

Obtida uma posição usando o \textit{Discrete-Space Estimator} torna-se necessário ainda usar o \textit{Continous-Space Estimator} para chegar a um valor mais próximo da localização real.

A primeira técnica é o centro de massa de \begin{math}N\end{math} posições obtidas. A posição estimada no espaço contínuo \begin{math}(x,y)\end{math} é obtida a partir das seguintes equações, considerando o espaço bi-dimensional utilizado neste trabalho:

\begin{equation}
x = \frac{\sum_{j=1}^{min(N,P)} x_iP_i}{\sum{}P_i}
\end{equation}
\begin{equation}
y = \frac{\sum_{j=1}^{min(N,P)} y_iP_i}{\sum{}P_i}
\end{equation}

Onde \begin{math}P\end{math} é o número de posições encontradas para um determinado nó móvel.

A segunda técnica consiste em fazer uma média temporal das \begin{math}K\end{math} posições encontradas numa localização anterior para o mesmo nó, dada pelas equações:

\begin{equation}
x = \frac{\sum_{j=1}^{K} x_i}{K}
\end{equation}
\begin{equation}
y = \frac{\sum_{j=1}^{K} y_i}{K}
\end{equation}

Neste trabalho serão usados os valores de base \begin{math}N=6\end{math} e \begin{math}K=10\end{math} referenciados em \cite{31} como valores com bons resultados numa situação real. Serão no entanto, obtidos resultados na simulação, de modo a aferir quais os valores que dão origem aos melhores resultados.

\subsection{Estruturas de Dados e Ficheiros XML}
\label{chap:5:sec:4.3}
São definidas duas estruturas de dados no \textit{HORUS} modificado.

Na Figura \ref{fig:18:horusModRadioMap} temos a estrutura de dados escolhida para guardar as posições obtidas à saída do \textit{Correlation Modeler}. O resultado é um conjunto de posições, onde para cada posição, existem várias funções de densidade de probabilidade para cada nó, \acfp{PDF} caracterizadas pelos seus valores de média e desvio padrão.

Na Figura \ref{fig:19:horusModRadioMapClusters} está representada a estrutura de dados utilizada para guardar os \textit{clusters}. 

Estas estruturas estão presentes no nó móvel e no nó fixo e servem para guardar em memória o conteúdo que será escrito ou lido nos ficheiros XML.Nesta simulação são, por isso, usados dois tipos de ficheiro XML para guardar o mapa rádio de posições e os \textit{clusters}. Estes ficheiros são gerados quando termina a simulação do modo \textit{offline} e carregados pelo nó base quando começa a simulação do modo \textit{online}. No Anexo \ref{list:a1:xmlRadioMap} está um exemplo de um ficheiro XML de posições rádio e no Anexo \ref{list:a1:xmlRadioMapCluster} pode ser consultado um exemplo de um ficheiro XML de clusters.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=1\textwidth]{img/05_horus_mod_radio_map.png}
  \caption{Estrutura de dados para armazenamento das posições do mapa rádio obtidas na fase \textit{offline}.}
  \label{fig:18:horusModRadioMap}
\end{figure}

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.4\textwidth]{img/05_horus_mod_radio_map_clusters.png}
  \caption{Estrutura de dados para armazenamento dos \textit{clusters} obtidos na fase \textit{offline}.}
  \label{fig:19:horusModRadioMapClusters}
\end{figure}

\subsection{Modo de Funcionamento}
\label{chap:5:sec:4.4}
Na camada de aplicação dos nós pertencentes ao \acs{EMoS} é definido o papel do nó da rede. Cada nó tem a sua camada própria, o que em termos reais corresponderia a um programa em \textit{nesC} a ser executado sobre o \textit{TinyOS}. 

O nó móvel e o nó base, têm ambos um papel fulcral na localização. Apresentam-se por isso nas Figuras \ref{fig:20:horusFlow01} e \ref{fig:21:horusFlow02} os fluxogramas correspondentes ao funcionamento da camada de aplicação desses nós no contexto da localização.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=1\textwidth]{img/05_horus_flow_01.png}
  \caption{Fluxograma do modo de funcionamento do nó móvel na localização.}
  \label{fig:20:horusFlow01}
\end{figure}

No fluxograma da Figura \ref{fig:20:horusFlow01} observamos o comportamento do nó móvel. Este nó está permanentemente a receber e guardar mensagens de assinatura vindas dos nós fixos espalhados pela casa. 

No ramo esquerdo do fluxograma podemos observar o que acontece quando uma assinatura de um nó fixo é recebida. Se o nó móvel estiver em modo de calibração, utilizado durante a fase \textit{offline}, o nó verifica se houve mudança de posição e se existem nós estáticos suficientes para considerar a posição válida. Caso tal aconteça são calculados os parâmetros da função densidade de probabilidade normal correspondente às potências amostradas (calculando-se a média e o desvio padrão) sendo o resultado guardado no mapa rádio. Pelo contrário se estivermos na fase \textit{online} são apenas registados os valores do endereço e potência de sinal recebidos.

Quando não está no modo de calibração, o nó móvel usa um conceito de agendamento do \acs{OMNeT++} que permite agendar eventos, através de mensagens que são enviadas, num determinado tempo da simulação, para o próprio nó. Assim este conceito é usado para enviar periodicamente mensagens para o nó base para que este possa calcular a posição do nó móvel. Este comportamento está exemplificado na ramo direito do fluxograma.

\clearpage

Por sua vez na Figura \ref{fig:21:horusFlow02} temos um fluxograma do modo de funcionamento do nó base. Este nó recebe de um nó móvel, por intermédio de um ou mais nós fixos, uma mensagem que contém as médias das potências de nós fixos, recebidas pelo nó móvel durante um determinado espaço de tempo. Assim quando o nó base recebe esta mensagem, ordena por potência de forma descendente e selecciona apenas os N primeiros, em que N representa o número de nós estáticos presentes em cada posição do mapa rádio. 

São então seleccionados os endereços dos dois primeiros nós estáticos da amostra que constituem a chave da amostra. Com a chave são obtidas as posições do \textit{cluster} cuja chave é igual à chave da amostra. Percorrendo então todas as posições obtidas é calculada para cada uma, a probabilidade do nó móvel estar nessa posição.

Se a probabilidade for maior que zero então é guardada numa lista. Uma vez percorridos todas as posições se ainda não houver na lista pelo menos uma posição, decrementa-se o valor de N e torna-se a obter as posições do \textit{cluster} para novo cálculo. Se N chegar a zero então o processo acaba sem conseguir determinar uma posição para o nó móvel. Se houver uma posição então é efectuada a estimação de espaço contínuo através do centro de massa das posições e é calculada a média temporal de espaço contínuo com as últimas posições calculadas em amostras anteriores.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.85\textwidth]{img/05_horus_flow_02.png}
  \caption{Fluxograma do modo de funcionamento do nó base na localização.}
  \label{fig:21:horusFlow02}
\end{figure}

\clearpage

\section{Mobilidade}
\label{chap:5:sec:5}

Neste trabalho são usados dois modelos de mobilidade implementados no \acs{MiXiM}. São eles o \textit{TurtleMobility} e o \textit{TractorMobility}. 

O \textit{TurtleMobility} permite criar um percurso com comandos introduzidos na simulação através dum ficheiro XML. Desta forma é simulado o movimento de uma pessoa dentro de uma casa de forma simples, flexível e sem ter de efectuar uma compilação do programa de cada vez que são feitas alterações ao movimento. Esta opção permite ainda que outra aplicação possa gerar um ficheiro XML com dados reais substituindo o ficheiro existente. No Anexo \ref{list:a1:xmlTurtleMobility} está um exemplo de um ficheiro XML de configuração do \textit{TurtleMobility}.

Por sua vez o \textit{TractorMobility} usado especificamente para a criação do mapa de rádio da simulação, na fase \textit{offline}, permite criar de forma simples um percurso para a obtenção de pontos igualmente espaçados, criando uma malha sobre todo o ambiente de simulação. Na Figura \ref{fig:22:tractorMobility} é possível observar um exemplo do percurso disponibilizado neste modelo. De notar que numa situação real seria impossível construir um mapa rádio igual devido à existência de paredes a meio do percurso, mas para um cenário de simulação onde o objectivo é obter um mapa de rádio minimamente de forma dinâmica e rápida, a solução encontrada é perfeitamente aceitável.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.85\textwidth]{img/05_tractor_mobility.png}
  \caption{Movimento do nó móvel durante a fase \textit{offline} usando o modelo \textit{TractorMobility} disponível no MiXiM.}
  \label{fig:22:tractorMobility}
\end{figure}

% Ensure that the next chapter starts in a odd page
\cleardoublepage